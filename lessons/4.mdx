---
title: Testing your Tier NFT
description: Add tests to your Tier NFT. Builds on knowledge from Lesson 3.
icons: ['solidity', 'hardhat', 'openzeppelin']
---

# Lesson 4: Testing your Tier NFT

In this lesson, we'll be adding automated tests for our smart contract from
Lesson 3.

## Why automated testing?

- How do you know your contract actually works?
- Once you know it works, how do you know it won't break when you make future
  changes?
- Particularly if you're a new engineer to the code-base. It may not be obvious
  when something breaks.
- I found a bug and fixed it. How do I know the bug won't come back again?

This is where automated test comes into. Tests are a tool for writing your code,
and making sure it it keeps working as expected when changes are made.

Of course this doesn't replace testing your smart contract for real on devnet,
but it's an important tool to knowing your contract will work as expected.

## Let's add some tests

### Add Test Framework

You've already setup hardhat in Lesson 2, which is also a great framework for
writing automated tests.

Assuming you already have hardhat running in your project, add a line in your
`scripts` section of `package.json" so it looks something like this:

```javascript
"scripts": {
  "test": "hardhat test --network hardhat"
},
```

Let's create an empty test file to get started in a `test` folder called
`tier-nft.test.js` with just these lines:

```javascript
const { expect } = require('chai')

describe('TierNFT', function () {
  it('placeholder test')
})
```

Now with both of those changes, run `npm test` and you should see:

```bash
$ npm test

> project1-nfts@1.0.0 test
> hardhat test --network hardhat



  TierNFT
    - placeholder test


  0 passing (5ms)
  1 pending
```

This now proves you:

- hardhat is running ok
- the tests are found and are running
- `pending` means we haven't added the real test yet since there is no function
  added to hold the test code. This is a good way to brainstorm the tests you
  want to write and add placeholders as reminders to implement those tests.

<ContentCallout emoji="ðŸ’¡" size="md" variant="info">
  Since we didn't introduce TypeScript in this project we won't discuss writing
  tests in TypeScript. Just mentioning here since TypeScript is something you'll
  want to learn more about and we may cover in a future lesson.
</ContentCallout>

### What do we want to test on our Tier NFT contract?

Now that the tools are setup, what are we really needing to test?

Let's look at our contract from Lesson 3

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

// for debugging
// import "hardhat/console.sol";

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant SVG_START = '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" fill="none" font-family="sans-serif"><defs><filter id="A" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="500" width="500"><feDropShadow dx="1" dy="2" stdDeviation="8" flood-opacity=".67" width="200%" height="200%" /></filter><linearGradient id="B" x1="0" y1="0" x2="15000" y2="0" gradientUnits="userSpaceOnUse"><stop offset=".05" stop-color="#ad00ff" /><stop offset=".23" stop-color="#4e00ec" /><stop offset=".41" stop-color="#ff00f5" /><stop offset=".59" stop-color="#e0e0e0" /><stop offset=".77" stop-color="#ffd810" /><stop offset=".95" stop-color="#ad00ff" /></linearGradient><linearGradient id="C" x1="0" y1="60" x2="0" y2="110" gradientUnits="userSpaceOnUse"><stop stop-color="#d040b8" /><stop offset="1" stop-color="#e0e0e0" /></linearGradient></defs><path fill="url(#B)" d="M0 0h15000v500H0z"><animateTransform attributeName="transform" attributeType="XML" type="translate" from="0 0" to="-14500 0" dur="16s" repeatCount="indefinite" /></path><circle fill="#1d1e20" cx="100" cy="90" r="45" filter="url(#A)" /><text x="101" y="99" text-anchor="middle" class="nftLogo" font-size="32px" fill="url(#C)" filter="url(#A)">D_D<animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 100 90" to="360 100 90" dur="5s" repeatCount="indefinite" /></text><g font-size="32" fill="#fff" filter="url(#A)"><text x="250" y="280" text-anchor="middle" class="tierName">';
string constant SVG_END = "</text></g></svg>";

string constant TIER_NAME_0 = "Basic";
string constant TIER_NAME_1 = "Medium";
string constant TIER_NAME_2 = "Premium";
uint256 constant TIER_VALUE_0 = 0.01 ether;
uint256 constant TIER_VALUE_1 = 0.02 ether;
uint256 constant TIER_VALUE_2 = 0.05 ether;

contract TierNFT is ERC721, Ownable {
    uint256 public totalSupply;
    mapping(uint256 => uint256) public tokenTier;

    constructor(string memory _name, string memory _symbol)
        ERC721(_name, _symbol)
    {}

    function mint() public payable {
        require(
            msg.value >= TIER_VALUE_0,
            "Not enough value for the minimum Tier"
        );

        uint256 tierId = 0;
        if (msg.value >= TIER_VALUE_2) {
            tierId = 2;
        } else if (msg.value >= TIER_VALUE_1) {
            tierId = 1;
        }

        totalSupply++;
        _safeMint(msg.sender, totalSupply);
        tokenTier[totalSupply] = tierId;
    }

    // Create the tokenURI json on the fly without creating files individually
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "Nonexistent token");

        string memory tierName = tokenTier[tokenId] == 2
            ? TIER_NAME_2
            : tokenTier[tokenId] == 1
            ? TIER_NAME_1
            : TIER_NAME_0;

        string memory imageSVG = string(
            abi.encodePacked(SVG_START, tierName, SVG_END)
        );

        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{"name": "',
                        name(),
                        " #",
                        Strings.toString(tokenId),
                        '", "description": "TierNFTs collection", "image": "data:image/svg+xml;base64,',
                        Base64.encode(bytes(imageSVG)),
                        '","attributes":[{"trait_type": "Tier", "value": "',
                        tierName,
                        '" }]}'
                    )
                )
            )
        );

        return string(abi.encodePacked("data:application/json;base64,", json));
    }

    // Function to withdraw funds from contract
    function withdraw() public onlyOwner {
        // Check that we have funds to withdraw
        uint256 balance = address(this).balance;
        require(balance > 0, "Balance should be > 0");

        // Withdraw funds.
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdraw failed");
    }
}
```

What is it trying to do?

- it's being initialized by a constructor and has some initial settings
- it accepts payment and mints NFTs
- it renders art as a SVG image
- it allows the contract owner to withdraw funds

If any of these functions are broken, you may not be able to mint NFTs, render
the correct art or withdraw funds at the end.

We want to test that those functions work in a variety of cases.

For example, we can test that a mint happens when enough Eth is spent, and that
a mint fails if there is not enough Eth spent.

### Writing start with tests for constructor(), mint() and withdraw()

Let's start with `constructor`. This one is pretty straight forward since the
heavy lifting is done by OpenZeppelin base classes, but let's make sure it
works.

Let's take a leap forward into some setup and our first two tests!

It's looks like a bunch, but we'll walk through. And this code includes setup
that we'll use for all the other tests too.

```javascript
const { expect } = require('chai')

const CONTRACT_NAME = 'TierNFT'
const COLLECTION_NAME = 'TierNFT'
const COLLECTION_SYMBOL = 'Tier'

describe('TierNFT', function () {
  let contract
  let owner
  let otherUser

  beforeEach(async function () {
    const Contract = await hre.ethers.getContractFactory(CONTRACT_NAME)

    const [_owner, _otherUser] = await hre.ethers.getSigners()
    owner = _owner
    otherUser = _otherUser

    contract = await Contract.deploy(COLLECTION_NAME, COLLECTION_SYMBOL)
    await contract.deployed()
  })

  describe('constructor', async () => {
    it('set proper collection name', async function () {
      const name = await contract.name()
      expect(name).to.equal('TierNFT')
    })

    it('set proper collection symbol', async function () {
      const symbol = await contract.symbol()
      expect(symbol).to.equal('Tier')
    })
  })
})
```

We're going to construct the contract in the test and so we set some fixed
constant values we'll use in the tests:

```javascript
const CONTRACT_NAME = 'TierNFT'
const COLLECTION_NAME = 'TierNFT'
const COLLECTION_SYMBOL = 'Tier'
```

Next is a `describe('TierNFT', function () {` line. What's cool about describe
is that it basically just groups tests together so you'll see nicely organized
output.

For example when we run the tests we see:

```bash
TierNFT
    constructor
      âœ” set proper collection name
      âœ” set proper collection symbol
```

Notice "TierNFT" comes from the first `describe()` block and `constructor` is
from the inner `describe()` block.

Next is a `beforeEach()` block. When tests run it's important that everything
get setup from scratch each time and this all happens here. "Before each" test,
this code will run and re-inialize everything for each test that runs. This way
one test result doesn't impact another.

What's the gist here?

The hardhat framework give us the tools to deploy our contract to a
locally-running blockchain. So when this blocks finishes, we have a fully
deployed contract, and a couple of wallets to use for testing -- `owner` is who
has all the permissions since it deployed the contract, and `otherUser` is a
wallet with less permissions -- these will be handy when testing `withdraw`
later on.

Those `let` statements above are to hold these values so we can use them
throughout all our tests.

Finally, we then come across our first two actual tests:

```javascript
it('set proper collection name', async function () {
  const name = await contract.name()
  expect(name).to.equal('TierNFT')
})

it('set proper collection symbol', async function () {
  const symbol = await contract.symbol()
  expect(symbol).to.equal('Tier')
})
```

Here are a couple of new things to notice:

- Tests should be as simple as possible. By moving setup code into
  `beforeEach()` that helps keep it simple as well. If you pack too much into a
  test, you could introduce bugs that may lead to incorrect tests, and if
  something fails, it may be hard to debug which piece actually failed.
- So it's best practice to have a separate test with one simple `expect` in
  each. In theory, we could have tested both the name and the symbol in one
  test, but see bullet 1 above!
- And a test has two pieces (besides the `beforeEach()` setup code): you run a
  method on the contract (also called "exercising a method") and then you test
  that the result is what you expect.

Oh, and when you write a test, always make sure it fails first! So try changing
`expect` line to test the name `Anita` instead of `TierNFT`, run the tests via
`npm test` and make sure it fails. If your test passes when you make an obvious
change like that, something is wrong with your test.

So you properly see:

```bash

  TierNFT
    construction
      1) set proper collection name
      âœ” set proper collection symbol


  1 passing (2s)
  1 failing

  1) TierNFT
       construction
         set proper collection name:

      AssertionError: expected 'TierNFT' to equal 'Anita'
      + expected - actual

      -TierNFT
      +Anita
```

### Let's add tests for mint()

Here's what we'll be adding:

```javascript
describe('mint', async () => {
  it('should not mint if value is below the minimum tier', async function () {
    await expect(
      contract.mint({
        value: hre.ethers.utils.parseEther('0.001'),
      }),
    ).to.be.revertedWith('Not enough value for the minimum Tier')
    await expect(await contract.totalSupply()).to.equal(0)
  })

  it('should increase total supply', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.01'),
    })
    await expect(await contract.totalSupply()).to.equal(1)
  })

  it('should mint Tier 0', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.01'),
    })
    await expect(await contract.tokenTier(1)).to.equal(0)
  })

  it('should mint Tier 1', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.02'),
    })
    await expect(await contract.tokenTier(1)).to.equal(1)
  })

  it('should mint Tier 2', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.05'),
    })
    await expect(await contract.tokenTier(1)).to.equal(2)
  })
})
```

This one introduces some new concepts that are very useful.

With minting, one needs to pay the right price, we should see the total supply
of TierNFTs rise with each mint, and since we're minting 3 different tiers, we
need to test each one of those.

The first test is a great example of how to test that an error occurs. If not
enough Eth is sent, the contract fails with an error and the transaction is
reverted as if nothing happened.

So the heavily lifting is in the
`await expect().to.be.revertedWith('Not enough value for the minimum Tier')`
line. The contract call is is temporarily removed here to highlight what's
happening. We're expecting the call to be reverted with that specific error
message from the contract.

The method itself looks like this:

```javascript
contract.mint({
  value: hre.ethers.utils.parseEther('0.001'),
})
```

Here we're just calling `mint()` with a parameter that sets the amount of Eth we
want to send. In this case `0.001` Eth is less than our contract minimum of
`0.01` Eth so this correctly fails and our test confirms this.

Now for the remaining mint tests, we want to prove success, so they all need to
mint with a minimum of `0.01` Eth so you'll see the same line at the top of the
remaining tests in this section.

And really each of those remaining tests all has a single `expect()` line and
test the various conditions upon a successful mint. And the tier-testing tests
each put in enough Eth to trigger a mint for the correct tier.

Notice each line tests the #1 token (`contract.tokenTier(1)`). Remember that
each test starts from scratch with no supply of NFTs, so after you mint one in a
test, you just have one token, the first one.

### Testing withdraw()

Let's look at `withdraw()` next with these 3 tests:

```javascript
describe('withdrawal', async () => {
  it('should error if not owner', async function () {
    await expect(contract.connect(otherUser).withdraw()).to.be.revertedWith(
      'Ownable: caller is not the owner',
    )
  })

  it('should error if balance is zero', async function () {
    await expect(contract.withdraw()).to.be.revertedWith(
      'Balance should be > 0',
    )
  })

  it('should success if owner', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.01'),
    })
    expect(await hre.ethers.provider.getBalance(contract.address)).to.equal(
      hre.ethers.utils.parseEther('0.01'),
    )
    await contract.withdraw()
    expect(await hre.ethers.provider.getBalance(contract.address)).to.equal(
      hre.ethers.utils.parseEther('0'),
    )
  })
})
```

You'll see similar patterns to the `mint()` tests prior, with a couple of
additional highlights:

- In the contract, only a `owner` can withdraw funds, so the first tests changes
  the user to `otherUser` and makes sure that wallet can not mint. See
  `contract.connect(otherUser)` for how to change users before calling the
  method.
- Another condition is to error if an owner tries to withdraw from a
  zero-balance contact
- Finally, let's make sure an owner can successfully withdraw funds. Notice the
  `withdraw()` method is surrounded by
  `hre.ethers.provider.getBalance(contract.address)` lines. When we mint on that
  first line, we know the contract now has `0.01` Eth so we check that after the
  mint, then run `withdraw` then check the balance again and it should be back
  to zero since all funds withdrawn. Ok, yes, we do have two `expect()` lines in
  one test that breaks our rule of one expect per test, but as long as the test
  is kept simple, we choose what makes sense for what we're trying to test.

## But what about testing tokenURI()?

Here's where things get even more interesting!

Notice the current version of `tokenURI()` in our contract outputs a giant
opaque Base64 string, which contains the JSON file with an embedded SVG image:

```
data:application/json;base64,eyJuYW1lIjog
iOiAiVGllck5GVHMgY29sbGVjdGlvbiIsICJpbWFn
zZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0Rvdkwz

-- removed 50 lines in between --

JSGRwWkhSb1BTSTFNREFpSUdobGFXZG9kRDBpTlRB
XWmhiV2xzZVQwaWMyRnVjeTF6WlhKcFppSStQR1Js
5c2IzSXRhVzUwWlhKd2IyeGhkR2x2YmkxbWFXeDBa
6W3sidHJhaXRfdHlwZSI6ICJUaWVyIiwgInZhbHVl
```

This is impossible to test because if you make a change to the code, you get a
different Base64 string but how do you know if it's correct?

What's I'd recommend here is to refactor this to make it easier to test.

But first, let's use the power of testing to make sure we don't break the
implementation as we refactor. Let's wrap `tokenURI()` with a test that **DOES**
capture this opaque string. This gives us a "safety net" as we refactor our
code. If we break things while dividing this problem into helper methods, the
test will help us discover that. We can then toss this test at the end.

First, here's the new contract that now contains a bunch of new helper methods
to make `tokenURI()` testing possible.

So you'll still see `tokenURI()` but the implementation in there is calling
various helper methods.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

// for debugging
// import "hardhat/console.sol";

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant SVG_START = '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" fill="none" font-family="sans-serif"><defs><filter id="A" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="500" width="500"><feDropShadow dx="1" dy="2" stdDeviation="8" flood-opacity=".67" width="200%" height="200%" /></filter><linearGradient id="B" x1="0" y1="0" x2="15000" y2="0" gradientUnits="userSpaceOnUse"><stop offset=".05" stop-color="#ad00ff" /><stop offset=".23" stop-color="#4e00ec" /><stop offset=".41" stop-color="#ff00f5" /><stop offset=".59" stop-color="#e0e0e0" /><stop offset=".77" stop-color="#ffd810" /><stop offset=".95" stop-color="#ad00ff" /></linearGradient><linearGradient id="C" x1="0" y1="60" x2="0" y2="110" gradientUnits="userSpaceOnUse"><stop stop-color="#d040b8" /><stop offset="1" stop-color="#e0e0e0" /></linearGradient></defs><path fill="url(#B)" d="M0 0h15000v500H0z"><animateTransform attributeName="transform" attributeType="XML" type="translate" from="0 0" to="-14500 0" dur="16s" repeatCount="indefinite" /></path><circle fill="#1d1e20" cx="100" cy="90" r="45" filter="url(#A)" /><text x="101" y="99" text-anchor="middle" class="nftLogo" font-size="32px" fill="url(#C)" filter="url(#A)">D_D<animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 100 90" to="360 100 90" dur="5s" repeatCount="indefinite" /></text><g font-size="32" fill="#fff" filter="url(#A)"><text x="250" y="280" text-anchor="middle" class="tierName">';
string constant SVG_END = "</text></g></svg>";

string constant TIER_NAME_0 = "Basic";
string constant TIER_NAME_1 = "Medium";
string constant TIER_NAME_2 = "Premium";
uint256 constant TIER_VALUE_0 = 0.01 ether;
uint256 constant TIER_VALUE_1 = 0.02 ether;
uint256 constant TIER_VALUE_2 = 0.05 ether;

contract TierNFT is ERC721, Ownable {
    uint256 public totalSupply;
    mapping(uint256 => uint256) public tokenTier;

    constructor(string memory _name, string memory _symbol)
        ERC721(_name, _symbol)
    {}

    function mint() public payable {
        require(
            msg.value >= TIER_VALUE_0,
            "Not enough value for the minimum Tier"
        );

        uint256 tierId = 0;
        if (msg.value >= TIER_VALUE_2) {
            tierId = 2;
        } else if (msg.value >= TIER_VALUE_1) {
            tierId = 1;
        }

        totalSupply++;
        _safeMint(msg.sender, totalSupply);
        tokenTier[totalSupply] = tierId;
    }

    function tierNameOf(uint256 _tokenTier)
        public
        pure
        returns (string memory)
    {
        if (_tokenTier == 0) return TIER_NAME_0;
        if (_tokenTier == 1) return TIER_NAME_1;
        return TIER_NAME_2;
    }

    function imageSVGOf(uint256 _tokenTier)
        public
        pure
        returns (string memory)
    {
        return
            string(
                abi.encodePacked(SVG_START, tierNameOf(_tokenTier), SVG_END)
            );
    }

    function finalJSON(
        string memory _name,
        uint256 _tokenId,
        string memory _imageSVG,
        uint256  _tokenTier
    ) public pure returns (string memory) {
        return
            string(
                abi.encodePacked(
                    '{"name": "',
                    _name,
                    " #",
                    Strings.toString(_tokenId),
                    '", "description": "TierNFTs collection", "image": "data:image/svg+xml;base64,',
                    _imageSVG,
                    '","attributes":[{"trait_type": "Tier", "value": "',
                    tierNameOf(_tokenTier),
                    '" }]}'
                )
            );
    }

    // Create the tokenURI json on the fly without creating files individually
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "Nonexistent token");

        // string memory tierName = tierNameOf(tokenTier[tokenId]);
        string memory imageSVG = imageSVGOf(tokenTier[tokenId]);

        string memory json = Base64.encode(
            bytes(
                finalJSON(
                    name(),
                    tokenId,
                    Base64.encode(bytes(imageSVG)),
                    tokenTier[tokenId]
                )
            )
        );

        return string(abi.encodePacked("data:application/json;base64,", json));
    }

    // Function to withdraw funds from contract
    function withdraw() public onlyOwner {
        // Check that we have funds to withdraw
        uint256 balance = address(this).balance;
        require(balance > 0, "Balance should be > 0");

        // Withdraw funds.
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdraw failed");
    }
}
```

Let's quickly describe the new helper methods. Each one breaks down the "create
an encoded SVG" problem into manageable functions that can each be tested and
understood by humans writing these tests.

- `tierNameOf()` just takes one of 3 tiers and returns the name of that tier.
  Easy to test!
- `imageSVGOf()` just concatenates three values into a string. Also easy to
  test.
- `finalJSON` also just concatenates multiple values into a string, and like the
  method says, it creates a string that represents the final JSON blob.
- Notice that none of these methods does the Base64 encoding, which immediately
  makes it impossible for a human to interpret the results and that makes for a
  bad test.
- So that does leave some lifting at the end still in `tokenURI()` but it's much
  simpler now. It calls well-tested helper methods that do the heavy lifting and
  finally does the dreaded Base64 encoding. Which tests, and how many to write,
  is subjective. In this case the non-automated-tested part is minimized and a
  test wasn't added. Though it is possible someone will come along, and with a
  typo break this file. It's up to you as a tester to decided if more tests are
  needed for peace of mind.

Ok, here are some tests for these helpers!

```javascript
describe('tokenURI and helpers', async () => {
  it('should error if token does not exist', async function () {
    await expect(contract.tokenURI(0)).to.be.revertedWith('Nonexistent token')
  })

  describe('tierNameOf', async function () {
    it('should return proper tier name for Tier 0', async function () {
      await expect(await contract.tierNameOf(0)).to.equal('Basic')
    })
    it('should return proper tier name for Tier 1', async function () {
      await expect(await contract.tierNameOf(1)).to.equal('Medium')
    })
    it('should return proper tier name for Tier 2', async function () {
      await expect(await contract.tierNameOf(2)).to.equal('Premium')
    })
    it('should return Tier 2 name if tier number greater than all tiers', async function () {
      await expect(await contract.tierNameOf(999)).to.equal('Premium')
    })
  })

  describe('imageSVGOf', async function () {
    it('should return proper imageSVG for Tier 0', async function () {
      await expect(await contract.imageSVGOf(0)).to.equal(
        '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" fill="none" font-family="sans-serif"><defs><filter id="A" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="500" width="500"><feDropShadow dx="1" dy="2" stdDeviation="8" flood-opacity=".67" width="200%" height="200%" /></filter><linearGradient id="B" x1="0" y1="0" x2="15000" y2="0" gradientUnits="userSpaceOnUse"><stop offset=".05" stop-color="#ad00ff" /><stop offset=".23" stop-color="#4e00ec" /><stop offset=".41" stop-color="#ff00f5" /><stop offset=".59" stop-color="#e0e0e0" /><stop offset=".77" stop-color="#ffd810" /><stop offset=".95" stop-color="#ad00ff" /></linearGradient><linearGradient id="C" x1="0" y1="60" x2="0" y2="110" gradientUnits="userSpaceOnUse"><stop stop-color="#d040b8" /><stop offset="1" stop-color="#e0e0e0" /></linearGradient></defs><path fill="url(#B)" d="M0 0h15000v500H0z"><animateTransform attributeName="transform" attributeType="XML" type="translate" from="0 0" to="-14500 0" dur="16s" repeatCount="indefinite" /></path><circle fill="#1d1e20" cx="100" cy="90" r="45" filter="url(#A)" /><text x="101" y="99" text-anchor="middle" class="nftLogo" font-size="32px" fill="url(#C)" filter="url(#A)">D_D<animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 100 90" to="360 100 90" dur="5s" repeatCount="indefinite" /></text><g font-size="32" fill="#fff" filter="url(#A)"><text x="250" y="280" text-anchor="middle" class="tierName">Basic</text></g></svg>',
      )
    })
    it('should return proper imageSVG for Tier 1', async function () {
      await expect(await contract.imageSVGOf(1)).to.equal(
        '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" fill="none" font-family="sans-serif"><defs><filter id="A" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="500" width="500"><feDropShadow dx="1" dy="2" stdDeviation="8" flood-opacity=".67" width="200%" height="200%" /></filter><linearGradient id="B" x1="0" y1="0" x2="15000" y2="0" gradientUnits="userSpaceOnUse"><stop offset=".05" stop-color="#ad00ff" /><stop offset=".23" stop-color="#4e00ec" /><stop offset=".41" stop-color="#ff00f5" /><stop offset=".59" stop-color="#e0e0e0" /><stop offset=".77" stop-color="#ffd810" /><stop offset=".95" stop-color="#ad00ff" /></linearGradient><linearGradient id="C" x1="0" y1="60" x2="0" y2="110" gradientUnits="userSpaceOnUse"><stop stop-color="#d040b8" /><stop offset="1" stop-color="#e0e0e0" /></linearGradient></defs><path fill="url(#B)" d="M0 0h15000v500H0z"><animateTransform attributeName="transform" attributeType="XML" type="translate" from="0 0" to="-14500 0" dur="16s" repeatCount="indefinite" /></path><circle fill="#1d1e20" cx="100" cy="90" r="45" filter="url(#A)" /><text x="101" y="99" text-anchor="middle" class="nftLogo" font-size="32px" fill="url(#C)" filter="url(#A)">D_D<animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 100 90" to="360 100 90" dur="5s" repeatCount="indefinite" /></text><g font-size="32" fill="#fff" filter="url(#A)"><text x="250" y="280" text-anchor="middle" class="tierName">Medium</text></g></svg>',
      )
    })
    it('should return proper imageSVG for Tier 2', async function () {
      await expect(await contract.imageSVGOf(2)).to.equal(
        '<svg xmlns="http://www.w3.org/2000/svg" width="500" height="500" fill="none" font-family="sans-serif"><defs><filter id="A" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="500" width="500"><feDropShadow dx="1" dy="2" stdDeviation="8" flood-opacity=".67" width="200%" height="200%" /></filter><linearGradient id="B" x1="0" y1="0" x2="15000" y2="0" gradientUnits="userSpaceOnUse"><stop offset=".05" stop-color="#ad00ff" /><stop offset=".23" stop-color="#4e00ec" /><stop offset=".41" stop-color="#ff00f5" /><stop offset=".59" stop-color="#e0e0e0" /><stop offset=".77" stop-color="#ffd810" /><stop offset=".95" stop-color="#ad00ff" /></linearGradient><linearGradient id="C" x1="0" y1="60" x2="0" y2="110" gradientUnits="userSpaceOnUse"><stop stop-color="#d040b8" /><stop offset="1" stop-color="#e0e0e0" /></linearGradient></defs><path fill="url(#B)" d="M0 0h15000v500H0z"><animateTransform attributeName="transform" attributeType="XML" type="translate" from="0 0" to="-14500 0" dur="16s" repeatCount="indefinite" /></path><circle fill="#1d1e20" cx="100" cy="90" r="45" filter="url(#A)" /><text x="101" y="99" text-anchor="middle" class="nftLogo" font-size="32px" fill="url(#C)" filter="url(#A)">D_D<animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 100 90" to="360 100 90" dur="5s" repeatCount="indefinite" /></text><g font-size="32" fill="#fff" filter="url(#A)"><text x="250" y="280" text-anchor="middle" class="tierName">Premium</text></g></svg>',
      )
    })
  })

  describe('finalJSON', async function () {
    it('should return proper finalJSON for Tier 0', async function () {
      await expect(
        await contract.finalJSON('TierNFT', 111, 'IMAGE_SVG_BASE64_HERE', 0),
      ).to.equal(
        '{"name": "TierNFT #111", "description": "TierNFTs collection", "image": "data:image/svg+xml;base64,IMAGE_SVG_BASE64_HERE","attributes":[{"trait_type": "Tier", "value": "Basic" }]}',
      )
    })

    it('should return proper finalJSON for Tier 1', async function () {
      await expect(
        await contract.finalJSON('TierNFT', 222, 'IMAGE_SVG_BASE64_HERE', 1),
      ).to.equal(
        '{"name": "TierNFT #222", "description": "TierNFTs collection", "image": "data:image/svg+xml;base64,IMAGE_SVG_BASE64_HERE","attributes":[{"trait_type": "Tier", "value": "Medium" }]}',
      )
    })

    it('should return proper finalJSON for Tier 2', async function () {
      await expect(
        await contract.finalJSON('TierNFT', 333, 'IMAGE_SVG_BASE64_HERE', 2),
      ).to.equal(
        '{"name": "TierNFT #333", "description": "TierNFTs collection", "image": "data:image/svg+xml;base64,IMAGE_SVG_BASE64_HERE","attributes":[{"trait_type": "Tier", "value": "Premium" }]}',
      )
    })
  })

  it('should return base64-encoded data for tokenURI for Tier 0', async function () {
    await contract.mint({
      value: hre.ethers.utils.parseEther('0.01'),
    })
    await expect(await contract.tokenURI(1)).to.equal(
      'data:application/json;base64, etc etc',
    )
  })
})
```

Since an SVG is basically a bunch of strings, you'll notice all these tests are
nearly simple single lines -- but they're comparing the results with long
strings that eventually make up the final SVG.

The final test is an example mentioned earlier about adding a test before
refactoring with helper methods. _I removed the whole base64 string since it was
too big to show here._ It just checks that the initial `tokenURI()` method (that
returns an encoded base64 string) returns the right result. It's helpful while
refactoring to make sure we didn't break things along the way, and it's helpful
at the end to ensure the `tokenURI()` method continues to work without fail when
code changes.

## Food for Thought

With all the helpfulness of tests, why didn't we start with tests before we
wrote any of the contract implementation?

The main reason was trying to minimize all the things you needed to learn to get
started, but the methodology when writing tests first is called "Test Driven
Development" (TDD).

TDD is a very powerful methodology which goes like this:

- Before you write implementation code, you write one or more tests and run
  them.
- Of course those tests fail initially since there are methods that don't have
  any implementaiton yet. As mentioned earlier, it's always important to prove
  your test fails initially.
- You then add your implementation until the tests pass.

Voila!

With TDD:

- you would have written tests as you go, which are much more fun to write than
  all at once at the end
- you would have ended up writing better code because you discover quickly when
  code is impossible to test. You'll end up with added benefit of breaking a big
  method into multiple smaller methods that are easily testable. So in the
  refactor example above for `tokenURI()` you would never have written the
  version that outputs a long base64 string because it's not testable.

  Bolting on tests after the fact can be painful, boring and you lose the
  potential code improvements you would have made if you tested as you go.

Go forth, test, and prosper with solid code you have confidence in deploying in
the world.
